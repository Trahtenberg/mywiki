Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-07-09T18:18:37+03:00

====== yiiframework.com ======
Created Monday 09 July 2018

yiiframework
	**Guide** - теория
		**ВВЕДЕНИЕ**
			+О Yii
				-высокопроизводительный компонентный PHP фреймворк
				-подходит для разработки порталов, форумов, CMS, магазинов или RESTful-приложений
			+Обновление с версии 1.1
		**ПЕРВОЕ ЗНАКОМСТВО**
			+Установка Yii
				-на виртуальный хостинг
					-basic - папка "web" должна переименоваться в "docs", "public_html", "htdocs" и тп. и тд. и настроить .htaccess
					-advanced - fronend и backend переносятся в структуру "/www/admin/" и настраиваются пути в index.php и index-text.php
			+Запуск приложения
				-точка входа в приложение, web/index.php, fronend/web/index.php
			+Говорим «привет»
				-контроллер
				-представление
			+Работа с формами
					-инфа - Yii::$app - это singleton
				-получение данных от пользователя
					-создается action в контроллере, "SiteController::actionEntry()"
					-создается модель формы, 
					-создается форма на основе модели, "views/site/entry"
					-Html::encode($model->name) - данные от пользователя экранируются для защиты от XSS-атак
					-из action контроллера можно вызывать разные представления,
						например, 1-й view - форма ввода, 2-й - форма подтверждения или информации
				-как создать модель для данных введенных пользователем
					"models/EntryForm.php"
				-валидация
						"models/EntryForm.php::rules()"
				-создание формы
					"views/site/entry"
			+Работа с базами данных
				-работает на PDO
				-бд доступно через Yii::$app->db
				-1.подключаемся к бд (yii2basic/config/db.php или yii2advanced/common/config/main.php)
				-2.создаем модель данных - потомок ActiveRecord - в [[/models/]]
				-3.создаем controller/action
					new Pagination - позволяет организовать paging - сам все организует, даже url
				-4.создаем view
					Html::encode - выводит тексты с защитой от XSS атак
					LinkPager - собсно пагинатор
			+Генерация кода при помощи Gii
				-включить gii (config/web.php)
		**СТРУКТУРА ПРИЛОЖЕНИЯ**
			+Обзор
				-приложение - веб или консольное
			+Входные скрипты - место запуска приложения - место объявления констант
					-basic 
					-web - yii.php, yii
					-console - config/console.php
				-в "bootstrap" конфигурации можно "положить" некий компонент и он будет загружаться.создаваться при старте
			+Приложения
				-конфигурация приложений
			+Компоненты приложения
				-элементы ключа "components" в файле конфигурации 
				-создаются при старте
				-доступны по \Yii::@app->componentID, например, \Yii::@app->db, \Yii::@app->request
				-некоторые из них можно "положить" в bootstrap
			+Контроллеры
				-контроллеры
					-в веб приложениях должны наследовать yii\web\Controller
						-в консольных приложениях должны наследовать yii\console\Controller
						-карта контроллеров - конфиг "controllerMap" - указание ID контроллера, не подходящего под стандарные правила
						-допустим я хочу назвать контроллер пользователя не UserController а AccountController
						-контроллер по умолчанию - "defaultRoute" - если контроллер не найден то покажи по умолчанию
				-действия
					-встроенные
					-отдельные 
						-объявляются в карте действий - это переопределение функции yii\base\Controller::actions() контроллера
						-объявляются как классы, наследующие yii\base\Action
					-параметры действий
						-для веб приложений берутся из $_GET
						-для консольных приложений берутся из аргументов командной строки
					-действие по умолчанию - index
						-чтобы переопределить, в контроллере добавить: public $defaultAction = 'home'; и действием по умолчанию станет "actionHome"
			+Модели
				-атрибуты
				-метки атрибутов
				-сценарии
				-валидация
				-массовое присвоение
				-безопасные и небезопасные атрибуты
				-экспорт данных
				-поля - обычные и экстра поля
			+Представления
				-рендеринг
					-в видах
					-в виджетах
					-в видах
					-в других местах
				-безопасность - Html::encode(), HtmlPurifier::process()
				-доступ к данным из вида - чтобы было доступно, надо передать при рендеринге в $this->render('', [переменные])
				-передача данных между видами - $this-params
				-ШАБЛОНЫ
					-располагаются в папке [[/layouts/]]
					-доступно/можно изменить через yii\base\Module::$layoutPath
					-шаблон по умолчанию "@app/views/layouts/main.php"
					-yii\base\Application::$layout - шаблон по умолчанию для всех контроллеров
					-yii\base\Controller::$layout - свой шаблон для контроллера
						достаточно в контроллере определить "public $layout = 'layoutfile';"
						-вложенные шаблоны
				-БЛОКИ
						-блок сперва создается, а потом, через несколько команд, показывается
					-$this->beginBlock('block1');  ...content...; $this->endBlock(); а потом → <?= $this->block('block1'); ?>
				-заголовок страницы - $this->title - также можно передать в шаблон
				-$this->registerMetaTag()
				-$this->registerLinkTag()
				-события в видах - EVENT_BEFORE_RENDER, EVENT_AFTER_RENDER,EVENT_BEGIN_PAGE, EVENT_END_PAGE, EVENT_BEGIN_BODY, EVENT_END_BODY
				-рендеринг статических страниц
			+Модули
				-м.б. только под приложением, например, под /frontend/ или под [[/console/]] - отдельно существовать не может
				-должен расширять \yii\base\Module
				-если конфигов много, то можно вынести в отдельный файл по аналогии с конфигом приложения
				-имеет структуру, аналогичную приложению: controllers, models, views
				-команды модуля можно включить в консоль
				-для использования надо объявить в конфигурации приложения: ['modules' => ['modulename' => ['class' => '\app\modules\ModuleName']]]
				-у модулей есть свои маршруты
				-модули могут быть вложенными друг в друга неограниченное колво раз
			+Фильтры
				-это объекты, которые могут запускаться как перед так и после действий контроллера
				-примеры фильтров: фильтр управления доступом, фильтр сжатия данных
				-объявляются в классе контроллера путём перекрытия метода behaviors()
				-еще можно объявить для приложения и модуля
				-создание: класс наследуется от \yii\base\ActionFilter и переопределяются методы beforeAction() и afterAction()
				-есть набор стандартных фильтров в \yii\filters: 
					-AccessControl - что доступно пользователю
					-ContentNegotiator - XML, JSON, ENG, GER
					-HttpCache - кеширование на стороне сервера посредством HTTP заголовков
					-PageCache - кеширование на стороне сервера содержимого или пока колво записей в таблице не изменится
					-RateLimiter - ограничитель колва запросов в сек, например для REST запросов
					-VerbFilter - разрешено ли запросам GET POST ... производить действия типа INSERT DELETE READ
					-Cors - фильтр использования ресурсов сайта сторонними сайтами или сервисами, например шрифты и стили использовать разрешить, а картинки не разрешать
			+Виджеты
				-блоки для представлений, напрмер, DatePcker, ActiveForm, menu, jquery, ...
				-создание: наследовать \yii\base\Widget, переопределить init() и run()
				-можно создать виджет с буфферизованным выводом init():ob_start() ... run():ob_get_clean() и вывести спомощью WidgetName::begin() ... WidgetName::end()
				-если вывод большой то можно расположить его в представлении и рендерить в run()
			+Ресурсы - Assets
				-подключаемые файлы, css, js, ...
				-можно/нужно соблюдать/задавать зависимости - например, если используется jquery, то надо указать эту зависимость через yii\web\AssetBundle::$depends
				-создание, надо наследовать yii\web\AssetBundle
				-можно использовать Bower и NPM пакеты, но предварительно надо настроить composer
				-как пользоваться? зарегистрировать для текущего представления: AppAsset::register($this); - $this - текущее представление
				-можно объединять и сжимать ресурсы
				-команда asset позволяет производить действия одноразово или перодически в консоли, напрмер сжатие css, js
				-группировка комплектов ресурсов, одну группу показывать, другую нет, одну сжимать, другую нет
			+Расширения
				-пакеты или библиотеки, 
				-можно грузить через composer
				-находится в папке "имярасширения" под [[/vendor/]]
				-разработка ведется только на github
				-имеется много расширений, которые ведутся командой yii
					-yiisoft/yii2-authclien - набор клиентов авторизации, Facebook OAuth2 клиент, GitHub OAuth2 клиент
					-yiisoft/yii2-bootstrap - набор виджетовBootstrap
					-yiisoft/yii2-codeception - тестирование на основе Codeception.
					-yiisoft/yii2-debug - отладка yii - включена в yii2-advanced
					-yiisoft/yii2-elasticsearch - поиск
					-yiisoft/yii2-gii
					-yiisoft/yii2-imagine - часто используемые функции для работы с изображениями
					-yiisoft/yii2-jui - набор виджетов JQuery UI
					-yiisoft/yii2-smarty
					-yiisoft/yii2-sphinx
					-yiisoft/yii2-swiftmailer
					-yiisoft/yii2-twig - шаблонизатор Twig
		**ОБРАБОТКА ЗАПРОСОВ**
			+Обзор
				-Пользователь создает запрос ко входному скрипту web/index.php.
				-Входной скрипт загружает конфигурацию и создает экземпляр приложения для обработки запроса.
				-Приложение определяет запрошенный маршрут при помощи компонента request.
				-Приложение создает экземпляр контроллера для обработки запроса.
				-Контроллер создает экземпляр действия и выполняет фильтры для этого действия.
				-При неудачном выполнении любого фильтра, действие не выполняется.
				-При успешном выполнении всех фильтров, выполняется действие.
				-Действие загружает модель данных, возможно, из базы данных.
				-Действие рендерит представление и передает ему модель данных.
				-Результат рендеринга передается в компонент приложения response.
				-Компонент response посылает готовые данные пользователю.
			+Bootstrapping - предзагрузка
				-1.во входном скрипте
					-настройка автозагрузчика классо
					-создание объекта приложения
				-2. в приложении
					-конфигурация приложени
					-создание обработчика ошибок
					-запуск компонентов предзагрузки приложения bootstrap()
					-вызов расширений
			+Разбор и генерация URL
				-основан на компоненте приложения \yii\web\UrlManager
				-2 формата
					-обычный
					-чпу
				-переключение через "enablePrettyUrl"
				-'catchAll' => ['site/offline'] переводит временно все запрсы на 'site/offline'
				-Url::to(), Url::home(), Url::base()
				-при чпу создается массив правил в "components -> urlManager -> rules"
				-Правила URL - это экземпляр класса yii\web\UrlRule
					-в маршрутах можно использовать регулярные выражения
					-можно использовать параметры : 'posts/<year:\d{4}>/<category>' => 'post/index',
				-в конфигурации можно дать возможность указывать суффиксы: 'suffix' => '.html'
					-суффикс "/" слэш - все Url будут заканчиваться слэшем
				-для SEO можно нормализовать Url: одинаковый адрес со слэшем и без
				-можно разделять типы HTTP запросов: 'PUT,POST post/<id:\d+>' => 'post/create'
				-можно создать свой класс правил, например для определения путей типа [[/Manufacturer/Model/Car/]] из БД
			+Запросы
				-класс yii\web\Request - то биш Yii::$app->request: get(), post(), isAjax(), isGet(), isPost(), isPut()
			Ответы
				-класс yii\web\Response
				-можно задать формат выходных данных: 
					-в actionIndex перед рендерингом \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
				-перенаправление (типовой header('Location: ...')) посредством yii\web\Response::redirect(): 
					return $this->redirect('http://example.com/new', 301);
				-возможна отправка файлов через HTTP-заголовок range
					return \Yii::$app->response->sendFile('path/to/file.txt');
					-нюанс, файл не отправляется до вызова yii\web\Response::send(), если надо срочно то надо вызвать yii\base\Application::run()
			+Сессии и куки
				-Yii::$app->session
					-можно настраивать место хранения сессии: в бд, в отдельном хранилище, в Redis, в MongoDB, Flash
						Redis - хранилище разного типа данных
						Flash - сессия на следующий раз и удалить
				-yii\web\Cookie
					 Yii::$app->request->cookies
			Обработка ошибок
				'components' => ['errorHandler' => ['errorAction' => 'site/error']] - при ошибке показывает site/error
			Логирование
				- Запись сообщений лога в различных частях кода приложения; Настройка целей лога в конфигурации приложения; Изучение отфильтрованных сообщений лога, например, при помощи Отладчика Yii.
				-Логи - Yii::debug() - Yii::info() - Yii::warning() - Yii::error()
				-Цели - yii\log\Target - фильтрует сообщения логов по уровню важности и категории, а затем выгружает их в соответствующее хранилище - бд, майл, файл
				-Форматирование сообщений - yii\log\Target::formatMessage()
				-Профилирование производительности
					-для измерения надо измеряемый код расположить между \Yii::beginProfile('myBenchmark'); ..... \Yii::endProfile('myBenchmark');
						а потом просмотреть в debug панели "Profiling" под названием "myBenchmark"
		**ОСНОВНЫЕ ПОНЯТИЯ**
			+Компоненты
				-классы наследующие \yii\base\Component
				-предоставляют: Свойства, События, Поведения
				-объект тяжелый, поэтому если не нужны события и поведения, то лучше создавать из \yii\base\BaseObject
			+Свойства
				-почти все внутренние объекты yii наследут \yii\base\BaseObject
				-к геттерам и сеттерам можно обращаться как к свойствам
			+События
				-это механизм для внедрения кода в определенные моменты времени/события
				-для работы с событиями предназначен \yii\base\Component
				-обработчик события - это callback-функция, срабатывающая при событии
					-присоединение обработчика: on
						$foo->on(Foo::EVENT_HELLO, 'function_name');
						$foo->on(Foo::EVENT_HELLO, function ($event) { // логика обработки события });
						$foo->on(Foo::EVENT_HELLO, 'function_name', 'abc'); - с передачей параметров
					-отсоединение обработчика - off
						$foo->off(Foo::EVENT_HELLO, 'function_name');
				можно самому инициировать событие - trigger
					Event::trigger(Foo::className(), Foo::EVENT_HELLO);
			+Поведения - behavior
				-потомки \yii\base\Behavior
			+Конфигурации
				-файлы/массивы включающие имена классов, значения свойств, обработчики событий, поведения
				-используется для создания объектов: Yii::CreateObject()
				-или для присвоения значений после создания: Yii::configure($object, $configure)
				-конфигурационные файлы - если конфиг очень большой, то можно разделить его на несколько файлов по теметике
				-у многих объектов есть конфа по умолчанию
					например, у виджета LinkPager есть параметр по умолчанию maxButtonCount=5, но при создании объекта можно перезаписать это значение
			+Псевдонимы
				-короткие ссылки на пути
				-м.б. к папке, к url, к файлу
				-можно сделать псевдоним из псевдонима
				-создание: Yii::setAlias('@foo', '/path/to/foo');
				-обратное преобразование: Yii::getAlias('@foo');
				-также в настройках приложения "aliases" можно указать изначальные пути
			+Автозагрузка классов
				-правила для автозагрузки:
					-каждый класс должен находитьсяя в отдельном классе
					-каждый класс должен принадлежать пространству имен
				-карта классов прямое указание класса и файла - обрабатывается без проверок, поэтому быстро
				-другие автозагрузчики - возможны, но загрузчик Yii д.б. последним
			+Service Locator
				-объект, предоставляющий всевозможные сервисы/компоненты
				-yii\di\ServiceLocator
					например, Yii::$app является ServiceLocator, а request, responce, urlManager - сервисами
					например, создание своего сервиса базы данных:
						$locator = new ServiceLocator;
						$locator->set('db', [
							'class' => 'yii\db\Connection',
							'dsn' => 'mysql:host=localhost;dbname=demo',
							'username' => 'root',
							'password' => '',
						]);
			+Dependency Injection Container
				-внедрение зависимостей - настройка экземпляра класса и зависимых от него объектов
				-тема из паттернов: function boo(Foo $foo) - т.е. указание типа переменной при вызове
				-типа внедрений:
					-через конструктор класса: function __construct(Bar $bar)
					-через метод: function doSomething($param1, \my\heavy\Dependency $something)
					-через сеттер: function setQux(Qux $qux)
					-через PHP-callback: $container->set('Foo', function() { $foo = new Foo(new Bar) });
				-зависимости можно зарегистрировать в контейнере
		**РАБОТА С БАЗАМИ ДАННЫХ**
			+Объекты доступа к данным (DAO)
				-для подключения создается объект БД yii\db\Connection
				-если это основное или частое соединение БД, то можно создсть как компоненту приложения 'components => db => ...'
				-объекты запросов:
					-yii\db\CreateCommand - queryAll(), queryOne(), queryColumn(), queryScalar()
						-для исключения SQL инъекций в SQL запросах желательно использовать привязку параметров 'SELECT * FROM articles WHERE id = :id'
							-1 параметр по значению - bindValue(':id', 5) - привязка одной переменной
							-несколько параметров по значению - $params = [':id'=>1,':type'=>3]; bindValues($params);
							-по ссылке - сперва подготовка bindParam($id); потом привязка и запрос $id=3; $command->queryOne();
						-при многочисленных связанных операциях желательно использовать транзакции
							Yii::$app->db->transaction(function($db){ sql операции })
							или в блоке try catch
							-транзакции могут иметь уровни изоляции:
								yii\db\Transaction::READ_UNCOMMITTED - низший уровень, «Грязное» чтение, не повторяющееся чтение и фантомное чтение.
								yii\db\Transaction::READ_COMMITTED - предотвращает «Грязное» чтение.
								yii\db\Transaction::REPEATABLE_READ - предотвращает «Грязное» чтение и не повторяющееся чтение.
								yii\db\Transaction::SERIALIZABLE - высший уровень, предотвращает все вышеуказанные проблемы.
							-трнзакции могут быть вложенными
				-yii\db\Connection поддерживает репликацию и разделение БД на масте-серверы и slave-серверы
				-схема данных \yii\db\TableSchema
			+Построитель запросов - yii\db\Query
				-в select можно использовать подзапросы, т.е. вставить объект yii\db\Query в качестве параметра
				-в from можно присвоить алиас таблицы
				-в JOIN в качестве таблицы можно использовать объект типа Query
				-методы выборки:
					all(): возвращает массив строк, каждая из которых это ассоциативный массив пар ключ-значение.
					one(): возвращает первую строку запроса.
					column(): возвращает первый столбец результата.
					scalar(): возвращает скалярное значение первого столбца первой строки результата.
					exists(): возвращает значение указывающее, что выборка содержит результат.
					count(): возвращает результат COUNT запроса.
				-из объекта yii\db\Query можно сформировать объект yii\db\Command:
					$command - (new yii\db\Query)->select()->from()->...->createCommand()
				-Query дает возможность пакетной выборки Query->batch() и Query->each()
			+Active Record
				-yii\db\ActiveRecord
				-yii\**db**\ActiveRecord и \yii\**mongodb**\ActiveRecord - это 2 разные БД: db и mongodb
				-по такому же принципу: yii\**db**\ActiveRecord и yii\**db2**\ActiveRecord - это разные бд одного сервера
				-почти тоже что и yii\db\Query - там new Query - а тут yii\db\ActiveRecord::find()
				-ActiveRecord класс - это таблица бд
				-объект ActiveRecord - это строка бд
				-атрибут объекта ActiveRecord - это поле таблицы
				-по умолчанию ActiveRecord использует подключение Yii::@app->db
					для использования другой бд необходимо переопределить метод ActiveRecord::getDb()
				-нюанс: методы FindOne() и One() не вызывают LIMIT 1, поэтому для улучшения производительности желательно явно вызывать  ->limit(1)->
				-yii\db\ActiveRecord::findBySql() - дает возможность простого SQL запроса
				-оптимистическая блокировка
				-связанные данные: hasOne(), hasMany()
				-промежуточная таблица - many-to-many - via(): посредством связи, viaTable(): посредством таблицы связи
				-отложенная и жадная загрузка - связанная таблица выступает как свойство основного
					жадная - прямо в запросе ->with()
					отложенная - сперва простой запрос, потом связанную таблицу
				-JOIN 
					-join() - полное описание связей
					-joinWith() - описание берется из связей hasOne() hasMany() объекта ActiveRecord
						-внутри joinWith() можно использовать функцию, где можно ограничить список
					-onCondition()
					-обратная связь hasMany()->inverseOf()
					-сохранение связанных данных, развязка - ->link(), unLink()
				-дополнительные аттрибуты
					например, в таблице "room" есть ширина и длина комнаты, а надо показать площадь,
					в классе делается новое свойство, и вычисляется
			+Миграции
				-объект yii\db\Migration использует конкретные типы данных - $this->string()
				-тогда как объект yii\db\Schema использует абстрактные типы данных, независимые от типа БД - Schema::TYPE_STRING
				-начиная с yii 2.0.7 работает умная строка - yii migrate/create create_post_table - создает класс с готовым кодом создания и удаления таблицы
					-а ключ --fields:id:int,name:string - создает готовый код для полей таблицы
				-также авто-код при команде: yii migrate/create add_position_column_to_post_table - добавит код для поля 'post.position'
				-create_junction_table_for_xxx_and_yyy_tables - промежуточная таблица
				-safeUp() safeDown() - обеспечивает транзакцию при миграции
				-перезагрузка миграций 'yii migrate/redo n' - отменит все миграции до указанного и применит все заново
				-отметка миграции - yii migrate/mark 150101_185401 - ничего не делает с БД но ставит метку что указанная миграция проведена
				-отдельные миграции - если нужно отдельно отслеживать разные миграции то настраивается 'controllerMap' => 'migrate-app', ..., 'migrate-module'
					обычная миграция - yii migrate/...
					новые - yii migrate-app/... - yii migrate-module/...
				-миграции в несколько БД
					-в консоли: yii migrate --db=db2
					-в коде: function init() { $this->db = 'db2'; parent::init(); }
		**ПОЛУЧЕНИЕ ДАННЫХ ОТ ПОЛЬЗОВАТЕЛЯ**
			+Создание форм
				-yii\widgets\ActiveForm - форма основанная на модели
				-модель м.б. основана на БД или произвольная:
					-yii\db\[[ActiveRecord]] - набор данных из БД
					или на 
					-yii\db\Model - произвольный набор данных - все создается в классе модели
					-ActiveRecord::field() добавляет в форму элемент, валидация которого происходит с помощью JS
					-если используется тема Bootstrap, то лучше использовать \yii\bootstrap\ActiveForm вместо \yii\widgets\ActiveForm
			+Валидация
				-model::validate()
			Загрузка файлов
			Табличный ввод
			Работа с несколькими моделями
		**ОТОБРАЖЕНИЕ ДАННЫХ**
			Форматирование данных
			Постраничная разбивка
			Сортировка
			Провайдеры данных
			Виджеты для данных
			Темизация
		**БЕЗОПАСНОСТЬ**
			Обзор
			Аутентификация
			Авторизация
			Работа с паролями
			Криптография
			Клиенты авторизации
			Лучшие практики
		**КЕШИРОВАНИЕ**
			Обзор
			Кэширование данных
			Кэширование фрагментов
			Кэширование страниц
			HTTP кэширование
		**ВЕБ-СЕРВИСЫ REST**
			Быстрый старт
			Ресурсы
			Контроллеры
			Роутинг
			Форматирование ответа
			Аутентификация
			Ограничение частоты запросов
			Версионирование
			Обработка ошибок
		**ИНСТРУМЕНТЫ РАЗРАБОТЧИКА**
			Отладочная панель и отладчик
			Генерация кода с Gii
			Генератор документации API
		**ТЕСТИРОВАНИЕ**
			Обзор
			Настройка тестового окружения
			Модульные тесты
			Функциональные тесты
			Приёмочные тесты
			Фикстуры
		**СПЕЦИАЛЬНЫЕ ТЕМЫ**
			Шаблон приложения advanced
			Создание приложения с нуля
			Консольные команды
			Встроенные валидаторы
			Интернационализация
			Отправка почты
			Оптимизация производительности
			Окружение виртуального хостинга
			Шаблонизаторы
			Работа со сторонним кодом
			Использование Yii в качестве микро-framework'а		
		**ВИДЖЕТЫ**
			GridView
			ListView
			DetailView
			ActiveForm
			Pjax
			Menu
			LinkPager
			LinkSorter
			Виджеты Bootstrap
			Виджеты Jquery UI
		**ХЕЛПЕРЫ**
			Обзор
			ArrayHelper
			Html
			Url хелпер
	API - документация по namespace-ам
	Wiki - как сделать то-то
	Extensions - расширения для yii2 - некоторые уже есть в коробке, 
		например можно скачать "yiisoft/yii2-jui" включающий такие виджеты как 
			Accordion
			AutoComplete
			DatePicker
			Dialog
			Draggable
			Droppable
			Menu
			ProgressBar
			Resizable
			Selectable
			Slider
			SliderInput
			Sortable
			Spinner
			Tabs
		
	
